vet_x1
length(vet_x1)
vet_x1 = list()
vet_y1 = list()
for(k in 1:N) {
tmp_score_index = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1 = x1[[k]][I1[[k]][l]+1]
tmp_y1 = y1[[k]][I1[[k]][l]+1]
}
vet_x1[[k]] = tmp_x1
vet_y1[[k]] = tmp_y1
}
vet_x1 = unlist(vet_x1)
vet_y1 = unlist(vet_y1)
vet_x1
vet_x1 = list()
vet_y1 = list()
for(k in 1:N) {
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1 = x1[[k]][I1[[k]][l]+1]
tmp_y1 = y1[[k]][I1[[k]][l]+1]
}
vet_x1[[k]] = tmp_x1
vet_y1[[k]] = tmp_y1
}
load("2020/data/input.RData")
load("2020/data/input_mod_2.RData") # não preciso dos dados do 3
vet_x1 = list()
vet_y1 = list()
for(k in 1:N) {
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1 = x1[[k]][I1[[k]][l]+1]
tmp_y1 = y1[[k]][I1[[k]][l]+1]
}
vet_x1[[k]] = tmp_x1
vet_y1[[k]] = tmp_y1
}
vet_x1 = unlist(vet_x1)
vet_y1 = unlist(vet_y1)
vet_x1
vet_x1
load("2020/data/input.RData")
load("2020/data/input_mod_2.RData") # não preciso dos dados do 3
vet_x1 = list()
vet_y1 = list()
1:(length(I1[[k]])-1)
k=1
1:(length(I1[[k]])-1)
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1 = x1[[k]][I1[[k]][l]+1]
tmp_y1 = y1[[k]][I1[[k]][l]+1]
}
tmp_x1
tmp_x2
tmp_x1
tmp_y1
load("2020/data/input.RData")
load("2020/data/input_mod_2.RData") # não preciso dos dados do 3
vet_x1 = list()
vet_y1 = list()
for(k in 1:N) {
tmp_x1 = NULL
tmp_x2 = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
vet_x1[[k]] = tmp_x1
vet_y1[[k]] = tmp_y1
}
vet_x1 = unlist(vet_x1)
vet_y1 = unlist(vet_y1)
vet_x1
length(vet_x1)
KL
L
L1
L1
length(vet_x1)
vet_x2 = list()
vet_y2 = list()
for(k in 1:N) {
tmp_x2 = NULL
tmp_y2 = NULL
for(l in 1:(length(I2[[k]])-1)) {
tmp_x2[l] = x1[[k]][I2[[k]][l]+1]
tmp_y2[l] = y1[[k]][I2[[k]][l]+1]
}
vet_x2[[k]] = tmp_x2
vet_y2[[k]] = tmp_y2
}
vet_x2 = unlist(vet_x2)
vet_y2 = unlist(vet_y2)
vet_x1
vet_y2
vet_x2 = list()
vet_y2 = list()
for(k in 1:N) {
tmp_x2 = NULL
tmp_y2 = NULL
for(l in 1:(length(I2[[k]])-1)) {
tmp_x2[l] = x2[[k]][I2[[k]][l]+1]
tmp_y2[l] = y2[[k]][I2[[k]][l]+1]
}
vet_x2[[k]] = tmp_x2
vet_y2[[k]] = tmp_y2
}
vet_x2 = unlist(vet_x2)
vet_y2 = unlist(vet_y2)
vet_x2
vet_x2
vet_y2
length(vet_x2)
length(vet_y2)
L2
L1
x
y
zero_1 = rep(0, L1)
zero_2 = rep(0, L2)
zero_1 = rep(0, L1)
zero_2 = rep(0, L2)
zero_1 = rep(0, L1)
zero_2 = rep(0, L2)
M1_lambda = cbind(M1_lambda, vet_x1, zero_1, zero_1, zero_1)
colnames(M1_lambda)
colnames(M1_lambda)[(2*n+3):(ncol(M1_lambda))]
zero_1 = rep(0, L1)
zero_2 = rep(0, L2)
M1_lambda = cbind(M1_lambda, vet_x1, vet_y1, zero_1, zero_1)
dim(M1_lambda)
dim(vet_x1)
length(vet_x1)
length(vet_y1)
load("2020/data/input.RData")
load("2020/data/input_mod_2.RData") # não preciso dos dados do 3
vet_x1 = list()
vet_y1 = list()
for(k in 1:N) {
tmp_x1 = NULL
tmp_y1 = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
vet_x1[[k]] = tmp_x1
vet_y1[[k]] = tmp_y1
}
vet_x1 = unlist(vet_x1)
vet_y1 = unlist(vet_y1)
vet_y1
M1_lambda = cbind(M1_lambda, vet_x1, vet_y1, zero_1, zero_1)
colnames(M1_lambda)[(2*n+3):(ncol(M1_lambda))] = c("x", "y", "0", "0")
M1_lambda
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/input_mod_4.R', encoding = 'UTF-8')
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_3.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(4)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
log_lik = -t(delta1)%*%exp(M1_lambda%*%theta) -t(delta1)%*%exp(M1_mu%*%theta) -t(delta2)%*%exp(M2_lambda%*%theta) -t(delta2)%*%exp(M2_mu%*%theta) +
t(H1)%*%M1_lambda%*%theta + t(A1)%*%M1_mu%*%theta + t(H2)%*%M2_lambda%*%theta + t(A2)%*%M2_mu%*%theta +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_4.R')
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_4.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(4)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
log_lik = -t(delta1)%*%exp(M1_lambda%*%theta) -t(delta1)%*%exp(M1_mu%*%theta) -t(delta2)%*%exp(M2_lambda%*%theta) -t(delta2)%*%exp(M2_mu%*%theta) +
t(H1)%*%M1_lambda%*%theta + t(A1)%*%M1_mu%*%theta + t(H2)%*%M2_lambda%*%theta + t(A2)%*%M2_mu%*%theta +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_4 = list(alpha = as.vector(c(solution$getValue(alpha))),
beta = as.vector(solution$getValue(beta)),
gamma = as.vector(solution$getValue(gamma)),
tau = as.vector(solution$getValue(tau)),
omega = as.vector(solution$getValue(omega)),
eta = as.vector(solution$getValue(eta)),
phi = as.vector(solution$getValue(phi)),
kappa = as.vector(solution$getValue(kappa)),
value = solution$value,
duration = duration)
names(mod_4$alpha) = times$Time
names(mod_4$beta) = times$Time
names(mod_4$omega) = c("lambda_x", "lambda_y", "mu_x", "mu_y")
save(mod_4, file = "2020/data/mod_4.RData")
mod_4
names(M1_lambda)
colnames(M1_lambda)
colnames(M1_mu)
colnames(M2_lambda)
colnames(M2_mu)
load("2020/data/input.RData")
load("2020/data/input_mod_2.RData") # não preciso dos dados do 3
vet_x1 = list()
vet_y1 = list()
x1[[k]][I1[[k]][l]+1]
k=1
I1[[k]]
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
vet_x1 = list()
vet_y1 = list()
tmp_x1 = NULL
tmp_y1 = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
tmp_x1
tmp_y1
I1
tmp_x1
tmp_y1
I1[[k]]
U1[1]
load("scrape/data/results.RData")
results[,1]
results[1,]
load("scrape/data/goals.RData")
head(goals, 5)
goals %>% filter(Match == 1, Season == 2020)
library(dplyr)
head(goals, 5)
goals %>% filter(Match == 1, Season == 2020)
tmp_x1
tmp_y1
k=2
tmp_x1 = NULL
tmp_y1 = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
tmp_x1
tmp_x2
tmp_y1
k=3
tmp_x1 = NULL
tmp_y1 = NULL
for(l in 1:(length(I1[[k]])-1)) {
tmp_x1[l] = x1[[k]][I1[[k]][l]+1]
tmp_y1[l] = y1[[k]][I1[[k]][l]+1]
}
tmp_x1
tmp_x1
tmp_y1
goals %>% filter(Match == k, Season == 2020)
I1[[k]]
k
delta_1
delta1
U1[4]
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_4.R')
mod_4
exp(-0.20783602)
solution
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2019/mod_3_outra_formulacao.R')
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2019/mod_3_outra_formulacao.R')
solution
mod_3
library(CVXR)
load("2019/data/input.RData")
load("2019/data/input_mod_3.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
lambda_xy = Variable(2)
mu_xy = Variable(2)
theta = vstack(alpha, beta, gamma, tau, lambda_xy, mu_xy)
eta = Variable(2)
phi = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
log_lik = -t(delta1)%*%exp(M1_lambda%*%theta) -t(delta1)%*%exp(M1_mu%*%theta) -t(delta2)%*%exp(M2_lambda%*%theta) -t(delta2)%*%exp(M2_mu%*%theta) +
t(H1)%*%M1_lambda%*%theta + t(A1)%*%M1_mu%*%theta + t(H2)%*%M2_lambda%*%theta + t(A2)%*%M2_mu%*%theta +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_3 = list(alpha = as.vector(c(solution$getValue(alpha))),
beta = as.vector(solution$getValue(beta)),
gamma = as.vector(solution$getValue(gamma)),
tau = as.vector(solution$getValue(tau)),
lambda_xy = as.vector(solution$getValue(lambda_xy)),
mu_xy = as.vector(solution$getValue(mu_xy)),
eta = as.vector(solution$getValue(eta)),
phi = as.vector(solution$getValue(phi)),
kappa = as.vector(solution$getValue(kappa)),
value = solution$value,
duration = duration)
names(mod_3$alpha) = times$Time
names(mod_3$beta) = times$Time
names(mod_3$lambda_xy) = c("10", "01")
names(mod_3$mu_xy) = c("10", "01")
mod_3
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_1.R')
mod_1
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_1.R')
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_2.R')
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_3.R')
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_4.R')
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/input_mod_1.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/input_mod_2.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/input_mod_3.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/mod_1.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/mod_2.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/mod_3.RData")
load("~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/data/mod_4.RData")
mod_1$value
mod_2$value
mod_3$value
mod_4$value
mod_4$omega["lambda_x"]
st = tibble(Model = 0:4,
eta_1 = c(NA, mod_1$eta[1], mod_2$eta[1], mod_3$eta[1], mod_4$eta[1]),
eta_2 = c(NA, mod_1$eta[2], mod_2$eta[2], mod_3$eta[2], mod_4$eta[2]),
phi_1 = c(NA, mod_1$phi[1], mod_2$phi[1], mod_3$phi[1], mod_4$phi[1]),
phi_2 = c(NA, mod_1$phi[2], mod_2$phi[2], mod_3$phi[2], mod_4$phi[2]),
kappa = c(NA, mod_1$kappa, mod_2$kappa, mod_3$kappa, mod_4$kappa)))
st = tibble(Model = 0:4,
eta_1 = c(NA, mod_1$eta[1], mod_2$eta[1], mod_3$eta[1], mod_4$eta[1]),
eta_2 = c(NA, mod_1$eta[2], mod_2$eta[2], mod_3$eta[2], mod_4$eta[2]),
phi_1 = c(NA, mod_1$phi[1], mod_2$phi[1], mod_3$phi[1], mod_4$phi[1]),
phi_2 = c(NA, mod_1$phi[2], mod_2$phi[2], mod_3$phi[2], mod_4$phi[2]),
kappa = c(NA, mod_1$kappa, mod_2$kappa, mod_3$kappa, mod_4$kappa))
kable(st, digits = 4, caption = "Stoppage time parameters",
col.names = c("Model", "$\\eta_1$", "$\\eta_2$", "$\\phi_1$", "$\\phi_2$", "$\\kappa$"))
library(knitr)
st = tibble(Model = 0:4,
eta_1 = c(NA, mod_1$eta[1], mod_2$eta[1], mod_3$eta[1], mod_4$eta[1]),
eta_2 = c(NA, mod_1$eta[2], mod_2$eta[2], mod_3$eta[2], mod_4$eta[2]),
phi_1 = c(NA, mod_1$phi[1], mod_2$phi[1], mod_3$phi[1], mod_4$phi[1]),
phi_2 = c(NA, mod_1$phi[2], mod_2$phi[2], mod_3$phi[2], mod_4$phi[2]),
kappa = c(NA, mod_1$kappa, mod_2$kappa, mod_3$kappa, mod_4$kappa))
kable(st, digits = 4, caption = "Stoppage time parameters",
col.names = c("Model", "$\\eta_1$", "$\\eta_2$", "$\\phi_1$", "$\\phi_2$", "$\\kappa$"))
rate = tibble(Model = 0:4,
gamma = c(exp(mod_0$gamma), exp(mod_1$gamma), exp(mod_2$gamma),
exp(mod_3$gamma), exp(mod_4$gamma)),
tau = c(NA, NA, exp(mod_2$tau), exp(mod_3$tau), exp(mod_4$tau)),
lambda_10 = c(NA, NA, NA, exp(mod_3$lambda_xy["10"]), mod_4$omega["lambda_x"]),
lambda_01 = c(NA, NA, NA, exp(mod_3$lambda_xy["01"]), mod_4$omega["lambda_y"]),
mu_10 = c(NA, NA, NA, exp(mod_3$mu_xy["10"]), mod_4$omega["mu_x"]),
mu_01 = c(NA, NA, NA, exp(mod_3$mu_xy["01"]), mod_4$omega["mu_y"]))
options(knitr.kable.NA = "–")
library(dplyr)
library(knitr)
load("data/input.RData")
load("data/mod_0.RData")
load("data/mod_1.RData")
load("data/mod_2.RData")
load("data/mod_3.RData")
load("data/mod_4.RData")
alphas = tibble(Time = times$Time,
mod_0 = exp(mod_0$alpha),
mod_1 = exp(mod_1$alpha),
mod_2 = exp(mod_2$alpha),
mod_3 = exp(mod_3$alpha),
mod_4 = exp(mod_4$alpha))
kable(alphas, digits = 4, caption = "Alphas")
betas = tibble(Time = times$Time,
mod_0 = exp(mod_0$beta),
mod_1 = exp(mod_1$beta),
mod_2 = exp(mod_2$beta),
mod_3 = exp(mod_3$beta),
mod_4 = exp(mod_4$beta))
kable(betas, digits = 4, caption = "Betas")
rate = tibble(Model = 0:4,
gamma = c(exp(mod_0$gamma), exp(mod_1$gamma), exp(mod_2$gamma),
exp(mod_3$gamma), exp(mod_4$gamma)),
tau = c(NA, NA, exp(mod_2$tau), exp(mod_3$tau), exp(mod_4$tau)),
lambda_10 = c(NA, NA, NA, exp(mod_3$lambda_xy["10"]), mod_4$omega["lambda_x"]),
lambda_01 = c(NA, NA, NA, exp(mod_3$lambda_xy["01"]), mod_4$omega["lambda_y"]),
mu_10 = c(NA, NA, NA, exp(mod_3$mu_xy["10"]), mod_4$omega["mu_x"]),
mu_01 = c(NA, NA, NA, exp(mod_3$mu_xy["01"]), mod_4$omega["mu_y"]))
kable(rate, digits = 4, caption = "Other parameters",
col.names = c("Model", "$\\gamma_h$", "$\\tau$",
"$\\lambda_{10} \\text{ or } \\omega_{\\lambda x}$",
"$\\lambda_{01} \\text{ or } \\omega_{\\lambda y}$",
"$\\mu_{10} \\text{ or } \\omega_{\\mu x}$",
"$\\mu_{01} \\text{ or } \\omega_{\\mu y}$",
"$\\eta_1$", "$\\eta_2$", "$\\phi_1$", "$\\phi_2$", "$\\kappa$"))
rate
rate = tibble(Model = 0:4,
gamma = c(exp(mod_0$gamma), exp(mod_1$gamma), exp(mod_2$gamma),
exp(mod_3$gamma), exp(mod_4$gamma)),
tau = c(NA, NA, exp(mod_2$tau), exp(mod_3$tau), exp(mod_4$tau)),
lambda_10 = c(NA, NA, NA, exp(mod_3$lambda_xy["10"]), mod_4$omega["lambda_x"]),
lambda_01 = c(NA, NA, NA, exp(mod_3$lambda_xy["01"]), mod_4$omega["lambda_y"]),
mu_10 = c(NA, NA, NA, exp(mod_3$mu_xy["10"]), mod_4$omega["mu_x"]),
mu_01 = c(NA, NA, NA, exp(mod_3$mu_xy["01"]), mod_4$omega["mu_y"]))
rate = tibble(Model = 0:4,
gamma = c(exp(mod_0$gamma), exp(mod_1$gamma), exp(mod_2$gamma),
exp(mod_3$gamma), exp(mod_4$gamma)),
tau = c(NA, NA, exp(mod_2$tau), exp(mod_3$tau), exp(mod_4$tau)),
lambda_10 = c(NA, NA, NA, exp(mod_3$lambda_xy["10"]), mod_4$omega["lambda_x"]),
lambda_01 = c(NA, NA, NA, exp(mod_3$lambda_xy["01"]), mod_4$omega["lambda_y"]),
mu_10 = c(NA, NA, NA, exp(mod_3$mu_xy["10"]), mod_4$omega["mu_x"]),
mu_01 = c(NA, NA, NA, exp(mod_3$mu_xy["01"]), mod_4$omega["mu_y"]))
kable(rate, digits = 4, caption = "Other parameters",
col.names = c("Model", "$\\gamma_h$", "$\\tau$",
"$\\lambda_{10} \\text{ or } \\omega_{\\lambda x}$",
"$\\lambda_{01} \\text{ or } \\omega_{\\lambda y}$",
"$\\mu_{10} \\text{ or } \\omega_{\\mu x}$",
"$\\mu_{01} \\text{ or } \\omega_{\\mu y}$"))
mod_0$value
mod_1$value
log_lik = tibble(Model = 1:4,
`log-likelihood` = c(mod_1$value, mod_2$value, mod_3$value, mod_4$value))
kable(log_lik, digits = 4, caption = "Log-likelihoods")
log_lik = tibble(Model = 1:4,
likelihood = exp(c(mod_1$value, mod_2$value, mod_3$value, mod_4$value)),
`log-likelihood` = c(mod_1$value, mod_2$value, mod_3$value, mod_4$value))
c(mod_1$value, mod_2$value, mod_3$value, mod_4$value)
options(knitr.kable.NA = "–")
library(dplyr)
library(knitr)
load("data/input.RData")
load("data/mod_0.RData")
load("data/mod_1.RData")
load("data/mod_2.RData")
load("data/mod_3.RData")
load("data/mod_4.RData")
alphas = tibble(Time = times$Time,
mod_0 = exp(mod_0$alpha),
mod_1 = exp(mod_1$alpha),
mod_2 = exp(mod_2$alpha),
mod_3 = exp(mod_3$alpha),
mod_4 = exp(mod_4$alpha))
kable(alphas, digits = 4, caption = "Alphas")
betas = tibble(Time = times$Time,
mod_0 = exp(mod_0$beta),
mod_1 = exp(mod_1$beta),
mod_2 = exp(mod_2$beta),
mod_3 = exp(mod_3$beta),
mod_4 = exp(mod_4$beta))
kable(betas, digits = 4, caption = "Betas")
rate = tibble(Model = 0:4,
gamma = c(exp(mod_0$gamma), exp(mod_1$gamma), exp(mod_2$gamma),
exp(mod_3$gamma), exp(mod_4$gamma)),
tau = c(NA, NA, exp(mod_2$tau), exp(mod_3$tau), exp(mod_4$tau)),
lambda_10 = c(NA, NA, NA, exp(mod_3$lambda_xy["10"]),
mod_4$omega["lambda_x"]),
lambda_01 = c(NA, NA, NA, exp(mod_3$lambda_xy["01"]),
mod_4$omega["lambda_y"]),
mu_10 = c(NA, NA, NA, exp(mod_3$mu_xy["10"]), mod_4$omega["mu_x"]),
mu_01 = c(NA, NA, NA, exp(mod_3$mu_xy["01"]), mod_4$omega["mu_y"]))
kable(rate, digits = 4, caption = "Other parameters",
col.names = c("Model", "$\\gamma_h$", "$\\tau$",
"$\\lambda_{10} \\text{ or } \\omega_{\\lambda x}$",
"$\\lambda_{01} \\text{ or } \\omega_{\\lambda y}$",
"$\\mu_{10} \\text{ or } \\omega_{\\mu x}$",
"$\\mu_{01} \\text{ or } \\omega_{\\mu y}$"))
st = tibble(Model = 0:4,
eta_1 = c(NA, mod_1$eta[1], mod_2$eta[1], mod_3$eta[1], mod_4$eta[1]),
eta_2 = c(NA, mod_1$eta[2], mod_2$eta[2], mod_3$eta[2], mod_4$eta[2]),
phi_1 = c(NA, mod_1$phi[1], mod_2$phi[1], mod_3$phi[1], mod_4$phi[1]),
phi_2 = c(NA, mod_1$phi[2], mod_2$phi[2], mod_3$phi[2], mod_4$phi[2]),
kappa = c(NA, mod_1$kappa, mod_2$kappa, mod_3$kappa, mod_4$kappa))
kable(st, digits = 4, caption = "Stoppage time parameters",
col.names = c("Model", "$\\eta_1$", "$\\eta_2$", "$\\phi_1$", "$\\phi_2$",
"$\\kappa$"))
log_lik = tibble(Model = 1:4,
likelihood = exp(c(mod_1$value, mod_2$value, mod_3$value, mod_4$value)),
`log-likelihood` = c(mod_1$value, mod_2$value, mod_3$value, mod_4$value))
kable(log_lik, digits = 4, caption = "Likelihoods")
c(mod_1$value, mod_2$value, mod_3$value, mod_4$value)
a = c(mod_1$value, mod_2$value, mod_3$value, mod_4$value)
exp(a)
exp(-931)
