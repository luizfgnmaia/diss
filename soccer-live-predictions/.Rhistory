t1 = I2s[[k]][l]
t2 = I2s[[k]][l+1]
tmp_int_reds_2[l] = 1/3*(t2^3 - t1^3) # <---
}
int_reds_2[[k]] = tmp_int_reds_2
}
int_reds_1 = unlist(int_reds_1)
int_reds_2 = unlist(int_reds_2)
a = Variable(2)
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[1]
loglambda2s = log(int_reds_2) + a[2]
logmu2s = log(int_reds_2) + a[2]
log_lik_reds = - sum_entries(exp(loglambda1s)) -
sum_entries(exp(logmu1s)) -
sum_entries(exp(loglambda2s)) -
sum_entries(exp(logmu2s)) +
sum_entries(H1s*loglambda1s) +
sum_entries(A1s*logmu1s) +
sum_entries(H2s*loglambda2s) +
sum_entries(A2s*logmu2s)
objective = Maximize(log_lik_reds)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
A = exp(as.vector(solution$getValue(a)))
names(A) = c("A_lambda", "A_mu")
A
t = seq(0, 90, by = 0.01)
rate_home = A[1] * t^2 # <---
rate_away = A[2] * t^2 # <---
rate_both = rate_home + rate_away
home %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_home),
col = "red", size = 1)
away %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_away), aes(x = t, y = rate_away),
col = "red", size = 1)
both %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_both),
col = "red", size = 1)
library(dplyr)
library(ggplot2)
library(CVXR)
load("scrape/data/reds.RData")
load("2015-2020/data/input.RData")
reds$Stoppage_Time[which(is.na(reds$Stoppage_Time))] = 0
reds = reds %>%
mutate(Minute = Minute + Stoppage_Time) %>%
filter(Minute <= 45)
reds$Minute[which(reds$Half == 2)] = reds$Minute[which(reds$Half == 2)] + 45
tib_zeros = tibble(Minute = 1:90, n = 0L)
complete_zeros <- function(tib_count) {
tib_count %>%
full_join(tib_zeros, by = c("Minute", "n")) %>%
group_by(Minute) %>%
summarise(n = sum(n))
}
home = reds %>%
filter(Team == 1) %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
both = reds %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
away = reds %>%
filter(Team == 2) %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
for(k in 1:N) {
I2s[[k]] = I2s[[k]] + 45
}
int_reds_1 = list(); int_reds_2 = list();
for(k in 1:N) {
tmp_int_reds_1 = NULL
for(l in 1:(length(I1s[[k]])-1)) {
t1 = I1s[[k]][l]
t2 = I1s[[k]][l+1]
tmp_int_reds_1[l] = 1/2*(t2^2 - t1^2) # <---
}
int_reds_1[[k]] = tmp_int_reds_1
}
for(k in 1:N) {
tmp_int_reds_2 = NULL
for(l in 1:(length(I2s[[k]])-1)) {
t1 = I2s[[k]][l]
t2 = I2s[[k]][l+1]
tmp_int_reds_2[l] = 1/2*(t2^2 - t1^2) # <---
}
int_reds_2[[k]] = tmp_int_reds_2
}
int_reds_1 = unlist(int_reds_1)
int_reds_2 = unlist(int_reds_2)
a = Variable(2)
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[1]
loglambda2s = log(int_reds_2) + a[2]
logmu2s = log(int_reds_2) + a[2]
log_lik_reds = - sum_entries(exp(loglambda1s)) -
sum_entries(exp(logmu1s)) -
sum_entries(exp(loglambda2s)) -
sum_entries(exp(logmu2s)) +
sum_entries(H1s*loglambda1s) +
sum_entries(A1s*logmu1s) +
sum_entries(H2s*loglambda2s) +
sum_entries(A2s*logmu2s)
objective = Maximize(log_lik_reds)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
A = exp(as.vector(solution$getValue(a)))
names(A) = c("A_lambda", "A_mu")
A
t = seq(0, 90, by = 0.01)
rate_home = A[1] * t # <---
rate_away = A[2] * t # <---
rate_both = rate_home + rate_away
home %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_home),
col = "red", size = 1)
away %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_away), aes(x = t, y = rate_away),
col = "red", size = 1)
both %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_both),
col = "red", size = 1)
solution$value
library(dplyr)
library(ggplot2)
library(CVXR)
load("scrape/data/reds.RData")
load("2015-2020/data/input.RData")
reds$Stoppage_Time[which(is.na(reds$Stoppage_Time))] = 0
reds = reds %>%
mutate(Minute = Minute + Stoppage_Time) %>%
filter(Minute <= 45)
reds$Minute[which(reds$Half == 2)] = reds$Minute[which(reds$Half == 2)] + 45
tib_zeros = tibble(Minute = 1:90, n = 0L)
complete_zeros <- function(tib_count) {
tib_count %>%
full_join(tib_zeros, by = c("Minute", "n")) %>%
group_by(Minute) %>%
summarise(n = sum(n))
}
home = reds %>%
filter(Team == 1) %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
both = reds %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
away = reds %>%
filter(Team == 2) %>%
count(Minute) %>%
complete_zeros() %>%
mutate(Rate = n/N)
for(k in 1:N) {
I2s[[k]] = I2s[[k]] + 45
}
int_reds_1 = list(); int_reds_2 = list();
for(k in 1:N) {
tmp_int_reds_1 = NULL
for(l in 1:(length(I1s[[k]])-1)) {
t1 = I1s[[k]][l]
t2 = I1s[[k]][l+1]
tmp_int_reds_1[l] = 1/2*(t2^2 - t1^2) # <---
}
int_reds_1[[k]] = tmp_int_reds_1
}
for(k in 1:N) {
tmp_int_reds_2 = NULL
for(l in 1:(length(I2s[[k]])-1)) {
t1 = I2s[[k]][l]
t2 = I2s[[k]][l+1]
tmp_int_reds_2[l] = 1/2*(t2^2 - t1^2) # <---
}
int_reds_2[[k]] = tmp_int_reds_2
}
int_reds_1 = unlist(int_reds_1)
int_reds_2 = unlist(int_reds_2)
a = Variable(2)
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[2]
loglambda2s = log(int_reds_2) + a[1]
logmu2s = log(int_reds_2) + a[2]
log_lik_reds = - sum_entries(exp(loglambda1s)) -
sum_entries(exp(logmu1s)) -
sum_entries(exp(loglambda2s)) -
sum_entries(exp(logmu2s)) +
sum_entries(H1s*loglambda1s) +
sum_entries(A1s*logmu1s) +
sum_entries(H2s*loglambda2s) +
sum_entries(A2s*logmu2s)
objective = Maximize(log_lik_reds)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
A = exp(as.vector(solution$getValue(a)))
names(A) = c("A_lambda", "A_mu")
A
t = seq(0, 90, by = 0.01)
rate_home = A[1] * t # <---
rate_away = A[2] * t # <---
rate_both = rate_home + rate_away
home %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_home),
col = "red", size = 1)
away %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_away), aes(x = t, y = rate_away),
col = "red", size = 1)
both %>%
ggplot(aes(x = Minute, y = Rate)) +
geom_line(size = 1) +
geom_point(size = 2) +
theme_bw() +
scale_x_continuous(breaks = seq(from = 0, to = 90, by = 10),
labels = c(seq(from = 0, to = 90, by = 10))) +
geom_line(data = tibble(t, rate_both), aes(x = t, y = rate_both),
col = "red", size = 1)
solution$value
solution$value
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_r1.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(8)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
rho = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1 + rho[1] * r1
pi2 = eta[2] + phi[2] * g2 + rho[2] * r2 + c * kappa
a = Variable(2)
loglambda1 = log(delta1) + M1_lambda %*% theta
logmu1 = log(delta1) + M1_mu %*% theta
loglambda2 = log(delta2) + M2_lambda %*% theta
logmu2 = log(delta2) + M2_mu %*% theta
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[2]
loglambda2s = log(int_reds_2) + a[1]
logmu2s = log(int_reds_2) + a[2]
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1s*loglambda1 + A1s*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2s*loglambda2 + A2s*logmu2)
log_lik_reds = sum_entries(
- exp(loglambda1s) - exp(logmu1s) +
H1s*loglambda1s + A1s*logmu1s) +
sum_entries(
- exp(loglambda2s) - exp(logmu2s) +
+ H2s*loglambda2s + A2s*logmu2s)
log_lik_st = t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
log_lik = log_lik_goals + log_lik_reds + log_lik_st
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_r1 = list(alpha = as.vector(c(solution$getValue(alpha))),
beta = as.vector(solution$getValue(beta)),
gamma = as.vector(solution$getValue(gamma)),
tau = as.vector(solution$getValue(tau)),
omega = as.vector(solution$getValue(omega)),
a = as.vector(solution$getValue(a)),
eta = as.vector(solution$getValue(eta)),
phi = as.vector(solution$getValue(phi)),
rho = as.vector(solution$getValue(rho)),
kappa = as.vector(solution$getValue(kappa)),
loglik = solution$value + sum(log(factorial(U1))) + sum(log(factorial(U2))),
duration = duration)
names(mod_r1$alpha) = times$Time
names(mod_r1$beta) = times$Time
names(mod_r1$a) = c("a_lambda", "a_mu")
names(mod_r1$omega) = c("lambda_x", "lambda_y", "mu_x", "mu_y",
"lambda_x^s", "lambda_y^s", "mu_x^s", "mu_y^s")
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_r1.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(8)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
rho = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1 + rho[1] * r1
pi2 = eta[2] + phi[2] * g2 + rho[2] * r2 + c * kappa
a = Variable(2)
loglambda1 = log(delta1) + M1_lambda %*% theta
logmu1 = log(delta1) + M1_mu %*% theta
loglambda2 = log(delta2) + M2_lambda %*% theta
logmu2 = log(delta2) + M2_mu %*% theta
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[2]
loglambda2s = log(int_reds_2) + a[1]
logmu2s = log(int_reds_2) + a[2]
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1s*loglambda1 + A1s*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2s*loglambda2 + A2s*logmu2)
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1*loglambda1 + A1*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2*loglambda2 + A2*logmu2)
log_lik_reds = sum_entries(
- exp(loglambda1s) - exp(logmu1s) +
H1s*loglambda1s + A1s*logmu1s) +
sum_entries(
- exp(loglambda2s) - exp(logmu2s) +
+ H2s*loglambda2s + A2s*logmu2s)
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1r*loglambda1 + A1r*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2r*loglambda2 + A2r*logmu2)
source('~/GitHub/soccer-live-predictions/soccer-live-predictions/2020/mod_r1.R', echo=TRUE)
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_r2.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(4)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
rho = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1 + rho[1] * r1
pi2 = eta[2] + phi[2] * g2 + rho[2] * r2 + c * kappa
a = Variable(2)
loglambda1 = log(delta1) + M1_lambda %*% theta
logmu1 = log(delta1) + M1_mu %*% theta
loglambda2 = log(delta2) + M2_lambda %*% theta
logmu2 = log(delta2) + M2_mu %*% theta
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[2]
loglambda2s = log(int_reds_2) + a[1]
logmu2s = log(int_reds_2) + a[2]
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1r*loglambda1 + A1r*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2r*loglambda2 + A2r*logmu2)
log_lik_reds = sum_entries(
- exp(loglambda1s) - exp(logmu1s) +
H1s*loglambda1s + A1s*logmu1s) +
sum_entries(
- exp(loglambda2s) - exp(logmu2s) +
+ H2s*loglambda2s + A2s*logmu2s)
log_lik_st = t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
log_lik = log_lik_goals + log_lik_reds + log_lik_st
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_r2 = list(alpha = as.vector(c(solution$getValue(alpha))),
beta = as.vector(solution$getValue(beta)),
gamma = as.vector(solution$getValue(gamma)),
tau = as.vector(solution$getValue(tau)),
omega = as.vector(solution$getValue(omega)),
a = as.vector(solution$getValue(a)),
eta = as.vector(solution$getValue(eta)),
phi = as.vector(solution$getValue(phi)),
rho = as.vector(solution$getValue(rho)),
kappa = as.vector(solution$getValue(kappa)),
loglik = solution$value + sum(log(factorial(U1))) + sum(log(factorial(U2))),
duration = duration)
names(mod_r2$alpha) = times$Time
names(mod_r2$beta) = times$Time
names(mod_r2$a) = c("a_lambda", "a_mu")
names(mod_r2$omega) = c("lambda_x-y", "mu_y-x", "lambda_y^s-x^s", "mu_x^s-y^s")
library(CVXR)
load("2020/data/input.RData")
load("2020/data/input_mod_r2.RData")
t0 = Sys.time()
alpha = Variable(n)
beta = Variable(n)
gamma = Variable(1)
tau = Variable(1)
omega = Variable(4)
theta = vstack(alpha, beta, gamma, tau, omega)
eta = Variable(2)
phi = Variable(2)
rho = Variable(2)
kappa = Variable(1)
pi1 = eta[1] + phi[1] * g1 + rho[1] * r1
pi2 = eta[2] + phi[2] * g2 + rho[2] * r2 + c * kappa
a = Variable(2)
loglambda1 = log(delta1) + M1_lambda %*% theta
logmu1 = log(delta1) + M1_mu %*% theta
loglambda2 = log(delta2) + M2_lambda %*% theta
logmu2 = log(delta2) + M2_mu %*% theta
loglambda1s = log(int_reds_1) + a[1]
logmu1s = log(int_reds_1) + a[2]
loglambda2s = log(int_reds_2) + a[1]
logmu2s = log(int_reds_2) + a[2]
log_lik_goals = sum_entries(
- exp(loglambda1) - exp(logmu1) +
H1r*loglambda1 + A1r*logmu1) +
sum_entries(
- exp(loglambda2) - exp(logmu2) +
+ H2r*loglambda2 + A2r*logmu2)
log_lik_reds = sum_entries(
- exp(loglambda1s) - exp(logmu1s) +
H1s*loglambda1s + A1s*logmu1s) +
sum_entries(
- exp(loglambda2s) - exp(logmu2s) +
+ H2s*loglambda2s + A2s*logmu2s)
log_lik_st = t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
log_lik = log_lik_goals + log_lik_reds + log_lik_st
objective = Maximize(log_lik)
constraints = list(sum(alpha) - sum(beta) == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_r2 = list(alpha = as.vector(c(solution$getValue(alpha))),
beta = as.vector(solution$getValue(beta)),
gamma = as.vector(solution$getValue(gamma)),
tau = as.vector(solution$getValue(tau)),
omega = as.vector(solution$getValue(omega)),
a = as.vector(solution$getValue(a)),
eta = as.vector(solution$getValue(eta)),
phi = as.vector(solution$getValue(phi)),
rho = as.vector(solution$getValue(rho)),
kappa = as.vector(solution$getValue(kappa)),
loglik = solution$value + sum(log(factorial(U1))) + sum(log(factorial(U2))),
duration = duration)
names(mod_r2$alpha) = times$Time
names(mod_r2$beta) = times$Time
names(mod_r2$a) = c("a_lambda", "a_mu")
names(mod_r2$omega) = c("lambda_x-y", "mu_y-x", "lambda_y^s-x^s", "mu_x^s-y^s")
mod_r2
exp(a)
exp(-7.927758)
mod_r2$loglik
