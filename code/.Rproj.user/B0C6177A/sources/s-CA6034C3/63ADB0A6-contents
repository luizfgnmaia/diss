
library(Rsolnp)

load("serie_a_2019.RData")

log_lik <- function(par) {
  
  log_lik_k <- function(k) { 
    
    lambda_xy <- function(t) {
      1
    }
    
    mu_xy <- function(t) {
      1
    }
    
    lambda_k <- function(t) {
      log(lambda_xy(t-1/90))+gamma+alpha[i[k]]+beta[j[k]]#+csi_1*t
    }
    
    mu_k <- function(t) {
      log(mu_xy(t-1/90))+alpha[j[k]]+beta[i[k]]#+csi_2*t
    }
    
    int_lambda <- function(t1, t2) { 
      exp(log(lambda_xy(t1))+gamma+alpha[i[k]]+beta[j[k]])*(t2-t1) #+ csi_1*(t2^2-t1^2)*0.5
    }
    
    int_mu <- function(t1, t2) { 
      exp(log(mu_xy(t1))+alpha[j[k]]+beta[i[k]])*(t2-t1) #+ csi_2*(t2^2-t1^2)*0.5
    }
    
    int_lambda_01 = 0 
    int_mu_01 = 0 
    for(int in 1:(length(lst_int[[k]])-1)) {
      int_lambda_01 = int_lambda_01 + int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
      int_mu_01 = int_mu_01 + int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
    }
    
    if(is.na(lst_J[[k]][1])) {  
      sum_l_mk = 0
    } else {
      sum_l_mk = sum((1-lst_J[[k]])*lambda_k(lst_t[[k]])+lst_J[[k]]*mu_k(lst_t[[k]]))
    }
    sum_l_mk - int_lambda_01 - int_mu_01
  }
  
  print(par)
  alpha = par[1:20]
  beta = par[21:40]
  gamma = par[41]
  csi_1 = par[42]
  csi_2 = par[43]
  
  ret = NULL
  for(k in 1:N) {
    ret[k] = log_lik_k(k)
  }
  -sum(ret)
}

set.seed(1)
#mod_2_Rsolnp = solnp(pars = rep(1, 43), log_lik, LB = rep(0, 43), eqfun = function(par) par[1], eqB = 1)
mod_2_Rsolnp = solnp(pars = rep(0, 43), log_lik, eqfun = function(par) par[1], eqB = 0)

exp(mod_2_Rsolnp$pars)