
library(CVXR)

load("serie_a_2019.RData")

alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
csi = Variable(2)

log_lik_k <- function(k) { 
  
  lambda_xy <- function(t) {
    1
  }
  
  mu_xy <- function(t) {
    1
  }
  
  lambda_k <- function(t) {
    log(lambda_xy(t-1/90))+gamma+alpha[i[k]]+beta[j[k]]
  }
  
  mu_k <- function(t) {
    log(mu_xy(t-1/90))+alpha[j[k]]+beta[i[k]]
  }
  
  int_lambda <- function(t1, t2) { 
    exp(log(lambda_xy(t1))+gamma+alpha[i[k]]+beta[j[k]])*(t2-t1) + csi[1]*(t2^2-t1^2)*0.5
  }
  
  int_mu <- function(t1, t2) { 
    exp(log(mu_xy(t1))+alpha[j[k]]+beta[i[k]])*(t2-t1) + csi[2]*(t2^2-t1^2)*0.5
  }
  
  int_lambda_01 = 0 
  int_mu_01 = 0 
  for(int in 1:(length(lst_int[[k]])-1)) {
    int_lambda_01 = int_lambda_01 + int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
    int_mu_01 = int_mu_01 + int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
  }
  
  if(is.na(lst_J[[k]][1])) {  
    sum_l_mk = 0
  } else {      # sum_l_mk nÃ£o segue o dcp
    sum_l_mk = sum((1-lst_J[[k]])*log(exp(lambda_k(lst_t[[k]]))+csi[1]*lst_t[[k]])+lst_J[[k]]*log(exp(mu_k(lst_t[[k]]))+csi[2]*lst_t[[k]]))
  }
  sum_l_mk - int_lambda_01 - int_mu_01
}

lst_log_lik = lapply(1:10, log_lik_k) # <-----------
expr = paste0("obj = ", paste(paste0("lst_log_lik[[", 1:10, "]]") , collapse = " + ")) # <-----------
eval(parse(text = expr))

objective = Maximize(obj)
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem, solver = "MOSEK")

mod_2_CVXR = list(par = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma),
                          solution$getValue(csi)),
                  value = solution$value)
# save(mod_2_CVXR, file = "sol/mod_2_CVXR.RData")
