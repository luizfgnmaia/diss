
library(CVXR)

load("serie_a_2019.RData")

t0 = Sys.time()

alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
lambda_xy = Variable(3)
mu_xy = Variable(3)

lst_sum_lambda = list()
lst_sum_mu = list()
for(k in 1:N) {
  tmp_sum_lambda = list()
  tmp_sum_mu = list()
  for(l in 1:(length(lst_int[[k]])-1)) {
    tmp_sum_lambda[[l]] = exp(alpha[i[k]]+beta[j[k]]+gamma+lambda_xy[score_index_3[[k]][l]]) * (lst_int[[k]][l+1]-lst_int[[k]][l])
    tmp_sum_mu[[l]] = exp(alpha[j[k]]+beta[i[k]]+mu_xy[score_index_3[[k]][l]]) * (lst_int[[k]][l+1]-lst_int[[k]][l])
  }
  lst_sum_lambda[[k]] = sum_entries(do.call(vstack, tmp_sum_lambda))
  lst_sum_mu[[k]] = sum_entries(do.call(vstack, tmp_sum_mu))
}
sum_lambda = sum_entries(do.call(vstack, lst_sum_lambda))
sum_mu = sum_entries(do.call(vstack, lst_sum_mu))

lst_sum_J = list()
for(k in 1:N) {
  if(is.na(lst_J[[k]][1])) {
    lst_sum_J[[k]] = 0
  } else {
    tmp_sum_J = list()
    for(l in 1:length(lst_J[[k]])) {
      if(lst_J[[k]][l] == 0) {
        tmp_sum_J[[l]] =  alpha[i[k]]+beta[j[k]]+gamma+lambda_xy[score_index_3[[k]][l]]
      } else {
        tmp_sum_J[[l]] = alpha[j[k]]+beta[i[k]]+mu_xy[score_index_3[[k]][l]]
      }
    }
    lst_sum_J[[k]] = sum_entries(do.call(vstack, tmp_sum_J))
  }
}
sum_J = sum_entries(do.call(vstack, lst_sum_J))

log_lik = DSFFSDFSD
objective = Maximize(log_lik)
problem = Problem(objective, constraints = list(alpha[1] == 0, lambda_xy[1] == 0, mu_xy[1] == 0))
set.seed(1)
solution = solve(problem, solver = "MOSEK")

duration = Sys.time() - t0

mod_2_CVXR = list(par = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma),
                          solution$getValue(lambda_xy)[2:3], solution$getValue(mu_xy)[2:3]),
                  value = solution$value,
                  duration = duration)
save(mod_2_CVXR, file = "sol/mod_2_CVXR.RData")

mod_2_CVXR$duration

load("sol/mod_2_Rsolnp.RData")
plot(exp(mod_2_CVXR$par), mod_2_Rsolnp$pars)
cor(exp(mod_2_CVXR$par), mod_2_Rsolnp$pars)
