load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
mod_0_CVXR = solve(problem)
save(mod_0_CVXR, file = "sol/mod_0_CVXR.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
lambda = alpha[i] * beta[j] * gamma
mu = alpha[j] * beta[i]
-sum(-lambda + x*log(lambda) - mu + y*log(mu))
}
set.seed(1)
mod_0_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_0_Rsolnp, file = "sol/mod_0_Rsolnp.RData")
load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
mod_0_CVXR = solve(problem)
save(mod_0_CVXR, file = "sol/mod_0_CVXR.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
lambda = alpha[i] * beta[j] * gamma
mu = alpha[j] * beta[i]
-sum(-lambda + x*log(lambda) - mu + y*log(mu))
}
set.seed(1)
mod_0_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_0_Rsolnp, file = "sol/mod_0_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]
}
mu_k <- function(t) {
mu_xy(t)*alpha[j[k]]*beta[i[k]]
}
int_lambda <- function(t1, t2) {
lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]] * (t2-t1)
}
int_mu <- function(t1, t2) {
mu_xy(t1)*alpha[j[k]]*beta[i[k]] * (t2-t1)
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_1_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_1_Rsolnp, file = "sol/mod_1_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]+csi_1*t
}
mu_k <- function(t) {
mu_xy(t)*alpha[j[k]]*beta[i[k]]+csi_2*t
}
int_lambda <- function(t1, t2) {
lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]]*(t2-t1) + csi_1*(t2^2-t1^2)*0.5
}
int_mu <- function(t1, t2) {
mu_xy(t1)*alpha[j[k]]*beta[i[k]]*(t2-t1) + csi_2*(t2^2-t1^2)*0.5
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
csi_1 = par[42]
csi_2 = par[43]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_2_Rsolnp = solnp(pars = rep(1, 43), log_lik, LB = rep(0, 43), eqfun = function(par) par[1], eqB = 1)
save(mod_2_Rsolnp, file = "sol/mod_2_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
ro_1^(t==0.5)*ro_2^(t==1)*lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]+csi_1*t
}
mu_k <- function(t) {
ro_1^(t==0.5)*ro_2^(t==1)*mu_xy(t)*alpha[j[k]]*beta[i[k]]+csi_2*t
}
int_lambda <- function(t1, t2) {
ro_1^(t2==0.5)*ro_2^(t2==1)*lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]]*(t2-t1) + csi_1*(t2^2-t1^2)*0.5
}
int_mu <- function(t1, t2) {
ro_1^(t2==0.5)*ro_2^(t2==1)*mu_xy(t1)*alpha[j[k]]*beta[i[k]]*(t2-t1) + csi_2*(t2^2-t1^2)*0.5
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
csi_1 = par[42]
csi_2 = par[43]
ro_1 = par[44]
ro_2 = par[45]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_3_Rsolnp = solnp(pars = rep(1, 45), log_lik, LB = rep(0, 45), eqfun = function(par) par[1], eqB = 1)
save(mod_3_Rsolnp, file = "sol/mod_3_Rsolnp.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem)
mod_0_CVXR = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma))
mod_0_CVXR
exp(mod_0_CVXR)
solution$value
mod_0_CVXR = list(par = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value)
mod_0_CVXR
source('~/diss/code/mod_2_CVXR.R', echo=TRUE)
load("~/diss/code/sol/mod_2_CVXR.RData")
exp(mod_2_CVXR$par)
(mod_2_CVXR$par)
mod_2_CVXR$par
mod_2_CVXR
load("~/diss/code/sol/mod_1_CVXR.RData")
exp(mod_1_CVXR)
exp(mod_1_CVXR$par)
library(Rmosek)
example(mosek)
library(CVXR)
installed_solvers()
attachbuilder()
library(Rmosek)
attachbuilder()
source("<RMOSEKDIR>/builder.R")
source("<RMOSEKDIR>/builder.R")
require("Rmosek")
library(Rmosek)
example(mosek)
install.packages("Rmosek")
install.packages("Rmosek")
##
#  File : affco1.R
#
#  Copyright : Copyright (c) MOSEK ApS, Denmark. All rights reserved.
#
#  Description :
#    Implements a basic tutorial example with affine conic constraints:
#
#    maximize x_1^(1/3) + (x_1+x_2+0.1)^(1/4)
#    st.      (x_1-0.5)^2 + (x_2-0.6)^2 <= 1
#             0 <= x_1 <= x_2 + 1
#
##
library("Rmosek")
affco1 <- function()
{
prob <- list(sense="max")
# Variables [x1; x2; t1; t2]
prob$c <- c(0, 0, 1, 1)
# Linear inequality x_1 - x_2 <= 1
prob$A <- Matrix(c(1, -1, 0, 0), nrow=1, sparse=TRUE)
prob$bc <- rbind(blc=-Inf, buc=1)
prob$bx <- rbind(blx=rep(-Inf,4), bux=rep(Inf,4))
# The quadratic cone
FQ <- rbind(c(0,0,0,0), c(1,0,0,0), c(0,1,0,0))
gQ <- c(1, -0.5, -0.6)
cQ <- matrix(list("QUAD", 3, NULL), nrow=3, ncol=1)
# The power cone for (x_1, 1, t_1) \in POW3^(1/3,2/3)
FP1 <- rbind(c(1,0,0,0), c(0,0,0,0), c(0,0,1,0))
gP1 <- c(0, 1, 0)
cP1 <- matrix(list("PPOW", 3, c(1/3, 2/3)), nrow=3, ncol=1)
# The power cone for (x_1+x_2+0.1, 1, t_2) \in POW3^(1/4,3/4)
FP2 <- rbind(c(1,1,0,0), c(0,0,0,0), c(0,0,0,1))
gP2 <- c(0.1, 1, 0)
cP2 <- matrix(list("PPOW", 3, c(1.0, 3.0)), nrow=3, ncol=1)
# All cones
prob$F <- rbind(FQ, FP1, FP2)
prob$g <- cbind(gQ, gP1, gP2)
prob$cones <- cbind(cQ, cP1, cP2)
rownames(prob$cones) <- c("type","dim","conepar")
r <- mosek(prob, list(soldetail=1))
stopifnot(identical(r$response$code, 0))
print(r$sol$itr$pobjval)
print(r$sol$itr$xx[1:2])
}
affco1()
source("C:/Program Files/Mosek/9.2/tools/platform/win64x86/rmosek/builder.R")
attachbuilder()
install.rmosek()
install.packages(pkgs = pkgs, repos = repos, type = type, INSTALL_opts = INSTALL_opts, configure.vars = configure.vars, ...)
require("Rmosek")
installed_solvers()
library(CVXR)
installed_solvers()
source("C:/Program Files/Mosek/9.2/tools/platform/win64x86/rmosek/builder.R")
install.rmosek()
attachbuilder()
install.rmosek()
install.packages(pkgs = pkgs, repos = repos, type = type, INSTALL_opts = INSTALL_opts, configure.vars = configure.vars, ...)
load("C:/Users/LuizFernando/Documents/diss/code/sol/mod_1_CVXR.RData")
mod_1_CVXR
mod_1_CVXR[[1]]
exp(mod_1_CVXR[[1]])
