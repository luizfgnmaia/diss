gamma = rep(1, N)
G_lambda = cbind(G_lambda, gamma)
G_lambda = G_lambda[,-1]
colnames(G_lambda) = c(paste0("alpha_", 2:20), paste0("beta", 1:20), "gamma")
G_mu = matrix(0, ncol = 40, nrow = N)
for(k in 1:N) {
alpha = rep(0, 20)
beta = rep(0, 20)
alpha[i[k]] = 1
beta[j[k]] = 1
tmp = c(alpha, beta)
G_mu[k,] = tmp
}
gamma = rep(0, N)
G_mu = cbind(G_mu, gamma)
G_mu = G_mu[,-1]
colnames(G_mu) = c(paste0("alpha_", 2:20), paste0("beta", 1:20), "gamma")
source('~/diss/code/dados_mod_1.R', echo=TRUE)
x
y
# betas tão MUITO baixos, conferir na hora de criar as matrizes
# não tá rodando com as partes das poissons
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
x
y
source('~/diss/code/dados_mod_1.R', echo=TRUE)
source('~/diss/code/dados_mod_1.R', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
diff1 = list()
diff2 = list()
for(k in 1:N) {
diff1[[k]] = diff(I1[[k]])
diff2[[k]] = diff(I2[[k]])
}
delta1 = unlist(diff1)
delta2 = unlist(diff2)
L1 = length(delta1)
L2 = length(delta2)
library(dplyr)
load("dados_serie_a_2019.RData")
# delta1, delta2, L1, L2, M1_lambda, M1_mu, M2_lambda, M2_mu
diff1 = list()
diff2 = list()
for(k in 1:N) {
diff1[[k]] = diff(I1[[k]])
diff2[[k]] = diff(I2[[k]])
}
delta1 = unlist(diff1)
delta2 = unlist(diff2)
L1 = length(delta1)
L2 = length(delta2)
L1
L2
delta1
LJ1
# LJ1, LJ2, J1, J2, G1_lambda, G1_mu, G2_lambda, G2_mu
LJ1 = length(unlist(J1))
LJ2 = length(unlist(J2))
LJ1
LJ2
View(G2_mu)
source('~/diss/code/dados_mod_1.R', echo=TRUE)
View(G2_mu)
delta1
delta2
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
# betas tão MUITO baixos, conferir as matrizes
# não tá rodando com as partes das poissons
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
delta1 = delta1/90
delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
# tau = Variable(2)
# phi = Variable(2)
# omega = Variable(2)
# pi1 = tau[1] + phi[1] * r1 + omega[1] * s1
# pi2 = tau[2] + phi[2] * r2 + omega[2] * s2
# log_lik = -t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta +
#   t(T1) %*% log(pi1) + t(T2) %*% log(pi2) + sum_entries(pi1) + sum_entries(pi2)
log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta
# log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(x) %*% G_lambda %*% theta + t(y) %*% G_mu %*% theta
objective = Maximize(log_lik)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_1 = list(par = c(0, solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value,
duration = duration)
save(mod_1, file = "mod_1.RData")
exp(mod_1$par)
load("dixon robinson/sol/mod_1_CVXR.RData")
plot(mod_1$par, mod_1_CVXR$par)
cor(mod_1$par, mod_1_CVXR$par)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"))
plot(mod_1$par, mod_1_CVXR$par, fill = c(rep("red", 19), rep("black", 20), "blue"))
points(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"))
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"))
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"), pch = 2)
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"), pch = 21)
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"), pch = 21)
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "blue"), pch = 19)
cor(mod_1$par, mod_1_CVXR$par)
source('~/diss/code/dados_mod_1.R', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
# betas tão MUITO baixos
# não tá rodando com as partes das poissons
# mudar a escala dos deltas tem diferença
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
delta1 = delta1/90
delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
# tau = Variable(2)
# phi = Variable(2)
# omega = Variable(2)
# pi1 = tau[1] + phi[1] * r1 + omega[1] * s1
# pi2 = tau[2] + phi[2] * r2 + omega[2] * s2
# log_lik = -t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta +
#   t(T1) %*% log(pi1) + t(T2) %*% log(pi2) + sum_entries(pi1) + sum_entries(pi2)
log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta
objective = Maximize(log_lik)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_1 = list(par = c(0, solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value,
duration = duration)
save(mod_1, file = "mod_1.RData")
exp(mod_1$par)
load("dixon robinson/sol/mod_1_CVXR.RData")
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "yellow"), pch = 19)
cor(mod_1$par, mod_1_CVXR$par)
# betas tão MUITO baixos
# não tá rodando com as partes das poissons
# mudar a escala dos deltas tem diferença
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
delta1 = delta1/90
delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
# tau = Variable(2)
# phi = Variable(2)
# omega = Variable(2)
# pi1 = tau[1] + phi[1] * r1 + omega[1] * s1
# pi2 = tau[2] + phi[2] * r2 + omega[2] * s2
# log_lik = -t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta +
#   t(T1) %*% log(pi1) + t(T2) %*% log(pi2) + sum_entries(pi1) + sum_entries(pi2)
log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta
objective = Maximize(log_lik)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_1 = list(par = c(0, solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value,
duration = duration)
save(mod_1, file = "mod_1.RData")
exp(mod_1$par)
load("dixon robinson/sol/mod_1_CVXR.RData")
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "skyblue"), pch = 19)
cor(mod_1$par, mod_1_CVXR$par)
# betas tão MUITO baixos
# não tá rodando com as partes das poissons
# mudar a escala dos deltas tem diferença
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
delta1 = delta1/90
delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
# tau = Variable(2)
# phi = Variable(2)
# omega = Variable(2)
# pi1 = tau[1] + phi[1] * r1 + omega[1] * s1
# pi2 = tau[2] + phi[2] * r2 + omega[2] * s2
# log_lik = -t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta +
#   t(T1) %*% log(pi1) + t(T2) %*% log(pi2) + sum_entries(pi1) + sum_entries(pi2)
log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta
objective = Maximize(log_lik)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_1 = list(par = c(0, solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value,
duration = duration)
save(mod_1, file = "mod_1.RData")
exp(mod_1$par)
load("dixon robinson/sol/mod_1_CVXR.RData")
plot(mod_1$par, mod_1_CVXR$par, col = c(rep("red", 19), rep("black", 20), "skyblue"), pch = 19,
xlab = "Novo", ylab = "Antigo")
cor(mod_1$par, mod_1_CVXR$par)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = param))
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par))
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
ggpoint()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
ggpoints()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_points()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point() +
theme_bw()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point(size = 1) +
theme_bw()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point(size = 3) +
theme_bw()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point(size = 2) +
theme_bw()
tibble(new = mod_1$par, old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point(size = 2) +
theme_bw()
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
solution
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
r1
s1
s2
r2
s1
r1
s1
r1
# Ainda não tá rodando com a parte das Poissons, ou seja, tá apenas calculando l(.|T)
# Mudar a escala dos deltas tem bastante impacto nos betas
library(dplyr)
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
# delta1 = delta1/90
# delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
r1
s1
r2
s2
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
solution
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_1.R', encoding = 'UTF-8', echo=TRUE)
mod_1_CVXR
solution$getValue("tau")
solution$getValue(tau)
source('~/diss/code/mod_1.R', echo=TRUE)
mod_1
source('~/diss/code/fit_T.R', echo=TRUE)
summary(fit_T1)
summary(fit_T2)
library(dplyr)
load("dados_serie_a_2019.RData")
#### T1
gols_t1 = unlist(lapply(t1, function(x) length(x < 45)))
reds_t1 = unlist(lapply(t1s, function(x) length(x < 45)))
fit_T1 = glm(T1 ~ gols_t1 + reds_t1)
summary(fit_T1)
#### T2
gols_t2 = unlist(lapply(t2, function(x) length(x < 90)))
reds_t2 = unlist(lapply(t2s, function(x) length(x < 90)))
fit_T2 = glm(T2 ~ gols_t2 + reds_t2)
summary(fit_T2)
library(ggplot2)
tibble(x = T1) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T1)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:9) +
ggtitle("T1")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
#geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
library(dplyr)
load("dados_serie_a_2019.RData")
#### T1
gols_t1 = unlist(lapply(t1, function(x) length(x < 45)))
reds_t1 = unlist(lapply(t1s, function(x) length(x < 45)))
fit_T1 = glm(T1 ~ gols_t1 + reds_t1)
summary(fit_T1)
#### T2
gols_t2 = unlist(lapply(t2, function(x) length(x < 90)))
reds_t2 = unlist(lapply(t2s, function(x) length(x < 90)))
fit_T2 = glm(T2 ~ gols_t2 + reds_t2)
summary(fit_T2)
library(ggplot2)
tibble(x = T1) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T1)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:9) +
ggtitle("T1")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
#geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
rm(list = setdiff(ls(), c("fit_T1", "fit_T2")))
save.image(file = "fit_T.RData")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
#geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
#ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
tibble(x = T1) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T1)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:9) +
ggtitle("T1")
library(dplyr)
load("dados_serie_a_2019.RData")
#### T1
gols_t1 = unlist(lapply(t1, function(x) length(x < 45)))
reds_t1 = unlist(lapply(t1s, function(x) length(x < 45)))
fit_T1 = glm(T1 ~ gols_t1 + reds_t1)
summary(fit_T1)
#### T2
gols_t2 = unlist(lapply(t2, function(x) length(x < 90)))
reds_t2 = unlist(lapply(t2s, function(x) length(x < 90)))
fit_T2 = glm(T2 ~ gols_t2 + reds_t2)
summary(fit_T2)
library(ggplot2)
tibble(x = T1) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T1)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:9) +
ggtitle("T1")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
tibble(x = T2) %>%
ggplot(aes(x = x)) +
geom_bar(aes(y = (..count..)/sum(..count..)), fill = "firebrick2", col = "black") +
#geom_density(data = tibble(x = fitted.values(fit_T2)), size = 1) +
theme_bw() +
#ylab("density") +
xlab("") +
scale_x_continuous(breaks = 0:12) +
ggtitle("T2")
rm(list = setdiff(ls(), c("fit_T1", "fit_T2")))
save.image(file = "fit_T.RData")
library(dplyr)
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
tau = Variable(2)
# Mudar a escala dos deltas tem bastante impacto nos betas
library(dplyr)
library(CVXR)
load("dados_serie_a_2019.RData")
load("dados_mod_1.RData")
# delta1 = delta1/90
# delta2 = delta2/90
t0 = Sys.time()
alpha = Variable(19)
beta = Variable(20)
gamma = Variable(1)
theta = vstack(alpha, beta, gamma)
tau = Variable(2)
phi = Variable(2)
omega = Variable(2)
pi1 = tau[1] + phi[1] * r1 + omega[1] * s1
pi2 = tau[2] + phi[2] * r2 + omega[2] * s2
log_lik = -t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta +
t(T1) %*% log(pi1) + t(T2) %*% log(pi2) - sum_entries(pi1) - sum_entries(pi2)
# log_lik = - t(delta1) %*% exp(M1_lambda %*% theta) - t(delta1) %*% exp(M1_mu %*% theta) - t(delta2) %*% exp(M2_lambda %*% theta) - t(delta2) %*% exp(M2_mu %*% theta) +
#   t(1-J1) %*% G1_lambda %*% theta + t(J1) %*% G1_mu %*% theta + t(1-J2) %*% G2_lambda %*% theta + t(J2) %*% G2_mu %*% theta
objective = Maximize(log_lik)
problem = Problem(objective)
set.seed(1)
solution = solve(problem, solver = "MOSEK")
duration = Sys.time() - t0
mod_1 = list(par = c(0, solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma),
solution$getValue(tau), solution$getValue(phi), solution$getValue(omega)),
value = solution$value,
duration = duration)
save(mod_1, file = "mod_1.RData")
library(ggplot2)
load("dixon robinson/sol/mod_1_CVXR.RData")
tibble(new = mod_1$par[1:41], old = mod_1_CVXR$par, par = c(rep("alpha", 20), rep("beta", 20), "gamma")) %>%
ggplot(aes(x = new, y = old, col = par)) +
geom_point(size = 2) +
theme_bw()
solution$par
solution$pars
mod_1$par
source('~/diss/code/mod_1.R', echo=TRUE)
mod_1$par
source('~/diss/code/mod_1.R', echo=TRUE)
