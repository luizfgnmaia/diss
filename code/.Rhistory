load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
mod_0_CVXR = solve(problem)
save(mod_0_CVXR, file = "sol/mod_0_CVXR.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
lambda = alpha[i] * beta[j] * gamma
mu = alpha[j] * beta[i]
-sum(-lambda + x*log(lambda) - mu + y*log(mu))
}
set.seed(1)
mod_0_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_0_Rsolnp, file = "sol/mod_0_Rsolnp.RData")
load("serie_a_2019.RData")
goals = c(x, y)
alpha = as.factor(c(i, j))
beta = as.factor(c(j, i))
gamma = c(rep(1, N), rep(0, N))
# View(model.matrix(~ beta + alpha + gamma - 1))
mod_0_glm = glm(goals ~ beta + alpha + gamma - 1, family = poisson)
save(mod_0_glm, file = "sol/mod_0_glm.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
mod_0_CVXR = solve(problem)
save(mod_0_CVXR, file = "sol/mod_0_CVXR.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
lambda = alpha[i] * beta[j] * gamma
mu = alpha[j] * beta[i]
-sum(-lambda + x*log(lambda) - mu + y*log(mu))
}
set.seed(1)
mod_0_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_0_Rsolnp, file = "sol/mod_0_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]
}
mu_k <- function(t) {
mu_xy(t)*alpha[j[k]]*beta[i[k]]
}
int_lambda <- function(t1, t2) {
lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]] * (t2-t1)
}
int_mu <- function(t1, t2) {
mu_xy(t1)*alpha[j[k]]*beta[i[k]] * (t2-t1)
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_1_Rsolnp = solnp(pars = rep(1, 41), log_lik, LB = rep(0, 41), eqfun = function(par) par[1], eqB = 1)
save(mod_1_Rsolnp, file = "sol/mod_1_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]+csi_1*t
}
mu_k <- function(t) {
mu_xy(t)*alpha[j[k]]*beta[i[k]]+csi_2*t
}
int_lambda <- function(t1, t2) {
lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]]*(t2-t1) + csi_1*(t2^2-t1^2)*0.5
}
int_mu <- function(t1, t2) {
mu_xy(t1)*alpha[j[k]]*beta[i[k]]*(t2-t1) + csi_2*(t2^2-t1^2)*0.5
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
csi_1 = par[42]
csi_2 = par[43]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_2_Rsolnp = solnp(pars = rep(1, 43), log_lik, LB = rep(0, 43), eqfun = function(par) par[1], eqB = 1)
save(mod_2_Rsolnp, file = "sol/mod_2_Rsolnp.RData")
library(Rsolnp)
load("serie_a_2019.RData")
log_lik <- function(par) {
log_lik_k <- function(k) {
lambda_xy <- function(t) {
1
}
mu_xy <- function(t) {
1
}
lambda_k <- function(t) {
ro_1^(t==0.5)*ro_2^(t==1)*lambda_xy(t)*gamma*alpha[i[k]]*beta[j[k]]+csi_1*t
}
mu_k <- function(t) {
ro_1^(t==0.5)*ro_2^(t==1)*mu_xy(t)*alpha[j[k]]*beta[i[k]]+csi_2*t
}
int_lambda <- function(t1, t2) {
ro_1^(t2==0.5)*ro_2^(t2==1)*lambda_xy(t1)*gamma*alpha[i[k]]*beta[j[k]]*(t2-t1) + csi_1*(t2^2-t1^2)*0.5
}
int_mu <- function(t1, t2) {
ro_1^(t2==0.5)*ro_2^(t2==1)*mu_xy(t1)*alpha[j[k]]*beta[i[k]]*(t2-t1) + csi_2*(t2^2-t1^2)*0.5
}
v_int_lambda = NULL
v_int_mu = NULL
for(int in 1:(length(lst_int[[k]])-1)) {
v_int_lambda[int] = int_lambda(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
v_int_mu[int] = int_mu(t1 = lst_int[[k]][int]/90, t2 = lst_int[[k]][int+1]/90)
}
sum_l_mk = ifelse(is.na(lst_J[[k]][1]), 0,
sum((1-lst_J[[k]])*log(lambda_k(lst_t[[k]]))+lst_J[[k]]*log(mu_k(lst_t[[k]]))))
sum_l_mk - sum(v_int_lambda) - sum(v_int_mu)
}
print(par)
alpha = par[1:20]
beta = par[21:40]
gamma = par[41]
csi_1 = par[42]
csi_2 = par[43]
ro_1 = par[44]
ro_2 = par[45]
ret = NULL
for(k in 1:N) {
ret[k] = log_lik_k(k)
}
-sum(ret)
}
set.seed(1)
mod_3_Rsolnp = solnp(pars = rep(1, 45), log_lik, LB = rep(0, 45), eqfun = function(par) par[1], eqB = 1)
save(mod_3_Rsolnp, file = "sol/mod_3_Rsolnp.RData")
library(CVXR)
load("serie_a_2019.RData")
log_lik <- function(alpha, beta, gamma) {
lambda = alpha[i] + beta[j] + gamma
mu = alpha[j] + beta[i]
sum(-exp(lambda) + x*lambda - exp(mu) + y*mu)
}
alpha = Variable(20)
beta = Variable(20)
gamma = Variable(1)
objective = Maximize(log_lik(alpha, beta, gamma))
constraints = list(alpha[1] == 0)
problem = Problem(objective, constraints)
set.seed(1)
solution = solve(problem)
mod_0_CVXR = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma))
mod_0_CVXR
exp(mod_0_CVXR)
solution$value
mod_0_CVXR = list(par = c(solution$getValue(alpha), solution$getValue(beta), solution$getValue(gamma)),
value = solution$value)
mod_0_CVXR
source('~/diss/code/mod_2_CVXR.R', echo=TRUE)
load("~/diss/code/sol/mod_2_CVXR.RData")
exp(mod_2_CVXR$par)
(mod_2_CVXR$par)
mod_2_CVXR$par
mod_2_CVXR
load("~/diss/code/sol/mod_1_CVXR.RData")
exp(mod_1_CVXR)
exp(mod_1_CVXR$par)
