gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
as.numeric(
(-1) *
(-t(delta1)%*%exp(M1_lambda%*%theta) -t(delta1)%*%exp(M1_mu%*%theta) -t(delta2)%*%exp(M2_lambda%*%theta) -t(delta2)%*%exp(M2_mu%*%theta) +
t(H1)%*%M1_lambda%*%theta + t(A1)%*%M1_mu%*%theta + t(H2)%*%M2_lambda%*%theta + t(A2)%*%M2_mu%*%theta +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
}
solution = solnp(pars = rep(1, 2*n+10), log_lik)
duration = Sys.time() - t0
mod_3_Rsolnp = list(alpha = c(0, solution$pars[1:(n-1)]),
beta = solution$pars[n:(2*n-1)],
gamma = solution$pars[2*n],
tau = solution$pars[2*n+1],
lambda_xy = solution$pars[c(2*n+2, 2*n+3)],
mu_xy = solution$pars[c(2*n+4, 2*n+5)],
eta = solution$pars[c(2*n+6, 2*n+7)],
phi = solution$pars[c(2*n+8, 2*n+9)],
kappa = kappa = solution$pars[2*n+10],
value = solution$value,
duration = duration)
names(mod_3_Rsolnp$alpha) = times$Time
names(mod_3_Rsolnp$beta) = times$Time
names(mod_3_Rsolnp$lambda_xy) = c("10", "01")
names(mod_3_Rsolnp$mu_xy) = c("10", "01")
# save(mod_3_Rsolnp, file = "mod_3_Rsolnp.RData")
source('~/diss/code/mod_3_Rsolnp.R', echo=TRUE)
source('~/diss/code/mod_3_Rsolnp.R', echo=TRUE)
source('~/diss/code/mod_3_Rsolnp.R', echo=TRUE)
warnings()
mod_3_Rsolnp
load("~/diss/code/mod_3.RData")
mod_3
solution$values
solution$value
value = -solution$values[length(solution$values)]
value
mod_3_Rsolnp = list(alpha = c(0, solution$pars[1:(n-1)]),
beta = solution$pars[n:(2*n-1)],
gamma = solution$pars[2*n],
tau = solution$pars[2*n+1],
lambda_xy = solution$pars[c(2*n+2, 2*n+3)],
mu_xy = solution$pars[c(2*n+4, 2*n+5)],
eta = solution$pars[c(2*n+6, 2*n+7)],
phi = solution$pars[c(2*n+8, 2*n+9)],
kappa = solution$pars[2*n+10],
value = -solution$values[length(solution$values)],
duration = duration)
mod_3
mod_3_Rsolnp
source('~/diss/code/mod_3_Rsolnp.R', echo=TRUE)
I1
library(dplyr)
load("dados_serie_a_2019.RData")
load("dados_mod_4.RData")
diff1
I1
I2
t1
t2
t1
t2
t1
t1
t1
t1
t2
T1
T2
k=1
1:length(I1[[k]]-1)
I1[[k]]
length(I1[[k]])-1
(length(I1[[k]])-1)
for(k in 1:N) {
len = length(I1[[k]])-1)
for(l in 1:len) {
t1_1[[k]] = I1[[k]](1:(len-1))
t1_2[[k]] = I1[[k]](2:len)
}
}
for(k in 1:N) {
len = length(I1[[k]])-1)
t1_1[[k]] = I1[[k]](1:(len-1))
t1_2[[k]] = I1[[k]](2:len)
}
a
len = length(I1[[k]])-1
len
k
I1[[k]]
for(k in 1:N) {
len = length(I1[[k]])-1
t1_1[[k]] = I1[[k]](1:(len-1))
t1_2[[k]] = I1[[k]](2:len)
}
I1[[k]](1:(len-1))
t1_1[[k]] = I1[[k]][1:(len-1)]
t1_1 = list()
t1_2 = list()
t2_1 = list()
t2_2 = list()
for(k in 1:N) {
len = length(I1[[k]])-1
t1_1[[k]] = I1[[k]][1:(len-1)]
t1_2[[k]] = I1[[k]][2:len]
}
len
t1_1
t2_1
t1_2
library(dplyr)
load("dados_serie_a_2019.RData")
load("dados_mod_3.RData")
t1_1 = list()
t1_2 = list()
t2_1 = list()
t2_2 = list()
for(k in 1:N) {
len = length(I1[[k]])-1
t1_1[[k]] = I1[[k]][1:(len-1)]
t2_1[[k]] = I1[[k]][2:len]
}
for(k in 1:N) {
len = length(I2[[k]])-1
t1_2[[k]] = I2[[k]][1:(len-1)]
t2_2[[k]] = I2[[k]][2:len]
}
t1_1
t1_2
t1_2
t2_2
for(k in 1:N) {
len = length(I1[[k]])-1
t1_1[[k]] = I1[[k]][1:(len-1)]
t2_1[[k]] = I1[[k]][2:len]
}
t1_1
t1[[380]]
t1_1[[380]]
t2_1[[380]]
library(dplyr)
load("dados_serie_a_2019.RData")
load("dados_mod_3.RData")
t1_1 = list()
t1_2 = list()
t2_1 = list()
t2_2 = list()
for(k in 1:N) {
len = length(I1[[k]])-1
t1_1[[k]] = I1[[k]][1:(len-1)]
t2_1[[k]] = I1[[k]][2:len]
}
for(k in 1:N) {
len = length(I2[[k]])-1
t1_2[[k]] = I2[[k]][1:(len-1)]
t2_2[[k]] = I2[[k]][2:len]
}
source('~/.active-rstudio-document', echo=TRUE)
dados_mod_4
t1_1
length(t1_1)
L1
L1
L2
length(delta)
length(delta1)
library(dplyr)
load("dados_serie_a_2019.RData")
load("dados_mod_3.RData")
# Para cada intervalo, preciso do t1 e do t2
t1_1 = list()
t2_1 = list()
t1_2 = list()
t2_2 = list()
for(k in 1:N) {
len = length(I1[[k]])
t1_1[[k]] = I1[[k]][1:(len-1)]
t2_1[[k]] = I1[[k]][2:len]
}
for(k in 1:N) {
len = length(I2[[k]])
t1_2[[k]] = I2[[k]][1:(len-1)]
t2_2[[k]] = I2[[k]][2:len]
}
t1_1 = unlist(t1_1)
t2_1 = unlist(t2_1)
t1_2 = unlist(t1_2)
t2_2 = unlist(t2_2)
length(t1_1)
length(t1_2)
library(dplyr)
load("dados_serie_a_2019.RData")
load("dados_mod_3.RData")
# Para cada intervalo, preciso do t1 e do t2
t1_1 = list()
t2_1 = list()
t1_2 = list()
t2_2 = list()
for(k in 1:N) {
len = length(I1[[k]])
t1_1[[k]] = I1[[k]][1:(len-1)]
t2_1[[k]] = I1[[k]][2:len]
}
for(k in 1:N) {
len = length(I2[[k]])
t1_2[[k]] = I2[[k]][1:(len-1)]
t2_2[[k]] = I2[[k]][2:len]
}
t1_1 = unlist(t1_1)
t2_1 = unlist(t2_1)
t1_2 = unlist(t1_2)
t2_2 = unlist(t2_2)
rm(list = setdiff(ls(), c("delta1", "delta2", "L1", "L2", "M1_lambda", "M1_mu", "M2_lambda",
"M2_mu", "g1", "r1", "g2", "r2", "c", "t1_1", "t1_2", "t2_1", "t2_2")))
save.image("dados_mod_4.RData")
source('~/diss/code/dados_mod_4.R', echo=TRUE)
source('~/diss/code/mod_4_Rsolnp.R', echo=TRUE)
t0 = Sys.time()
log_lik <- function(par) {
print(par)
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
lambda1 = delta1 * exp(M1_lambda %*% theta)
mu1 = delta1 * exp(M1_mu %*% theta)
lambda2 = delta2 * exp(M2_lambda %*% theta)
mu2 = delta2 * exp(M2_mu %*% theta)
loglambda1 = log(delta1) + M1_lambda %*% theta
logmu1 = log(delta1) + M1_mu %*% theta
loglambda2 = log(delta2) + M2_lambda %*% theta
logmu2 = log(delta2) + M2_mu %*% theta
as.numeric(
(-1) *( - sum(lambda1) - sum(mu1) - sum(lambda2) - sum(mu2) +
sum(H1*loglambda1) + sum(A1*logmu1) + sum(H2*loglambda2) + sum(A2*logmu2) +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
}
pars = rep(1, 2*n+10)
log_lik(pars)
log_lik <- function(par) {
print(par)
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
lambda1 = delta1 * exp(M1_lambda %*% theta)
mu1 = delta1 * exp(M1_mu %*% theta)
lambda2 = delta2 * exp(M2_lambda %*% theta)
mu2 = delta2 * exp(M2_mu %*% theta)
loglambda1 = M1_lambda %*% theta
logmu1 = M1_mu %*% theta
loglambda2 = M2_lambda %*% theta
logmu2 = M2_mu %*% theta
as.numeric(
(-1) *( - sum(lambda1) - sum(mu1) - sum(lambda2) - sum(mu2) +
sum(H1*loglambda1) + sum(A1*logmu1) + sum(H2*loglambda2) + sum(A2*logmu2) +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
}
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
par = pars
print(par)
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
lambda1 = delta1 * exp(M1_lambda %*% theta)
mu1 = delta1 * exp(M1_mu %*% theta)
lambda2 = delta2 * exp(M2_lambda %*% theta)
mu2 = delta2 * exp(M2_mu %*% theta)
loglambda1 = M1_lambda %*% theta
logmu1 = M1_mu %*% theta
loglambda2 = M2_lambda %*% theta
logmu2 = M2_mu %*% theta
as.numeric(
(-1) *( - sum(lambda1) - sum(mu1) - sum(lambda2) - sum(mu2) +
sum(H1*loglambda1) + sum(A1*logmu1) + sum(H2*loglambda2) + sum(A2*logmu2) +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
set.seed(1)
solution = solnp(pars = rep(1, 2*n+10), log_lik)
mod_4_Rsolnp
duration = Sys.time() - t0
mod_4_Rsolnp = list(alpha = c(0, solution$pars[1:(n-1)]),
beta = solution$pars[n:(2*n-1)],
gamma = solution$pars[2*n],
tau = solution$pars[2*n+1],
lambda_xy = solution$pars[c(2*n+2, 2*n+3)],
mu_xy = solution$pars[c(2*n+4, 2*n+5)],
eta = solution$pars[c(2*n+6, 2*n+7)],
phi = solution$pars[c(2*n+8, 2*n+9)],
kappa = solution$pars[2*n+10],
value = -solution$values[length(solution$values)],
duration = duration)
names(mod_4_Rsolnp$alpha) = times$Time
names(mod_4_Rsolnp$beta) = times$Time
names(mod_4_Rsolnp$lambda_xy) = c("10", "01")
names(mod_4_Rsolnp$mu_xy) = c("10", "01")
mod_4_Rsolnp
source('~/diss/code/mod_4_Rsolnp.R', echo=TRUE)
t2_1
pars
par
par = rep(1, 2*n+12)
print(par)
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
csi = par[c(2*n+11, 2*n+12)]
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
f_t_csi_1 = ((t_2_1+1)^(csi[1]) - (t_1_2+1)^(csi[1])) / (csi[1]+1)
load("dados_mod_4.RData")
load("dados_serie_a_2019.RData")
f_t_csi_1 = ((t_2_1+1)^(csi[1]) - (t_1_2+1)^(csi[1])) / (csi[1]+1)
t_2
f_t_csi_1 = ((t2_1+1)^(csi[1]) - (t1_2+1)^(csi[1])) / (csi[1]+1)
f_t_csi_1 = ((t2_1+1)^(csi[1]) - (t1_1+1)^(csi[1])) / (csi[1]+1)
f_t_csi_1
f_t_csi_2 = ((t2_2+1)^(csi[2]) - (t1_2+1)^(csi[2])) / (csi[2]+1)
f_t_csi_1_1 = ((t2_1+1)^(csi[1]) - (t1_1+1)^(csi[1])) / (csi[1]+1)
# Mandante segundo tempo
f_t_csi_1_2 = ((t2_2+1)^(csi[1]) - (t1_2+1)^(csi[1])) / (csi[1]+1)
# Visitante primeiro tempo
f_t_csi_2_1 = ((t2_1+1)^(csi[2]) - (t1_1+1)^(csi[1])) / (csi[2]+1)
# Visitante segundo tempo
f_t_csi_2_2 = ((t2_2+1)^(csi[2]) - (t1_2+1)^(csi[1])) / (csi[2]+1)
# Mandante primeiro tempo
f_t_csi_1_1 = ((t2_1+1)^(csi[1]) - (t1_1+1)^(csi[1])) / (csi[1]+1)
# Visitante primeiro tempo
f_t_csi_2_1 = ((t2_1+1)^(csi[2]) - (t1_1+1)^(csi[1])) / (csi[2]+1)
# Mandante segundo tempo
f_t_csi_1_2 = ((t2_2+1)^(csi[1]) - (t1_2+1)^(csi[1])) / (csi[1]+1)
# Visitante segundo tempo
f_t_csi_2_2 = ((t2_2+1)^(csi[2]) - (t1_2+1)^(csi[1])) / (csi[2]+1)
lambda1 = exp(M1_lambda %*% theta) * f_t_csi_1_1
mu1 = exp(M1_mu %*% theta) * f_t_csi_2_1
lambda2 = exp(M2_lambda %*% theta) * f_t_csi_1_2
mu2 = exp(M2_mu %*% theta) * f_t_csi_2_2
lambda1 = exp(M1_lambda %*% theta) * f_t_csi_1_1
lambda1
loglambda1 = M1_lambda %*% theta + log(f_t_csi_1_1)
loglambda1
M1_lambda %*% theta
lambda1 = exp(M1_lambda %*% theta) * f_t_csi_1_1
mu1 = exp(M1_mu %*% theta) * f_t_csi_2_1
lambda2 = exp(M2_lambda %*% theta) * f_t_csi_1_2
mu2 = exp(M2_mu %*% theta) * f_t_csi_2_2
loglambda1 = M1_lambda %*% theta + log(f_t_csi_1_1)
logmu1 = M1_mu %*% theta + log(f_t_csi_2_1)
loglambda2 = M2_lambda %*% theta + log(f_t_csi_1_2)
logmu2 = M2_mu %*% theta + log(f_t_csi_2_2)
as.numeric(
(-1) *( - sum(lambda1) - sum(mu1) - sum(lambda2) - sum(mu2) +
sum(H1*loglambda1) + sum(A1*logmu1) + sum(H2*loglambda2) + sum(A2*logmu2) +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
- sum(lambda1)
sum(H1*loglambda1)
loglambda1
H1*loglambda1
a = log(f_t_csi_1_1)
a[74]
a[674]
t2_1[674]
t1_1[674]
f_t_csi_1_1[674]
0/1
log(0)
sum(lambda1, na.rm = TRUE)
sum(H1*loglambda1, na.rm = TRUE)
library(dplyr)
library(Rsolnp)
load("dados_serie_a_2019.RData")
load("dados_mod_4.RData")
t0 = Sys.time()
log_lik <- function(par) {
print(par)
alpha = par[1:(n-1)]
beta = par[n:(2*n-1)]
gamma = par[2*n]
tau = par[2*n+1]
lambda_xy = par[c(2*n+2, 2*n+3)]
mu_xy = par[c(2*n+4, 2*n+5)]
theta = c(alpha, beta, gamma, tau, lambda_xy, mu_xy)
csi = par[c(2*n+11, 2*n+12)]
eta = par[c(2*n+6, 2*n+7)]
phi = par[c(2*n+8, 2*n+9)]
kappa = par[2*n+10]
pi1 = eta[1] + phi[1] * g1
pi2 = eta[2] + phi[2] * g2 + c * kappa
# Mandante primeiro tempo
f_t_csi_1_1 = ((t2_1+1)^(csi[1]) - (t1_1+1)^(csi[1])) / (csi[1]+1)
# Visitante primeiro tempo
f_t_csi_2_1 = ((t2_1+1)^(csi[2]) - (t1_1+1)^(csi[1])) / (csi[2]+1)
# Mandante segundo tempo
f_t_csi_1_2 = ((t2_2+1)^(csi[1]) - (t1_2+1)^(csi[1])) / (csi[1]+1)
# Visitante segundo tempo
f_t_csi_2_2 = ((t2_2+1)^(csi[2]) - (t1_2+1)^(csi[1])) / (csi[2]+1)
lambda1 = exp(M1_lambda %*% theta) * f_t_csi_1_1
mu1 = exp(M1_mu %*% theta) * f_t_csi_2_1
lambda2 = exp(M2_lambda %*% theta) * f_t_csi_1_2
mu2 = exp(M2_mu %*% theta) * f_t_csi_2_2
loglambda1 = M1_lambda %*% theta + log(f_t_csi_1_1)
logmu1 = M1_mu %*% theta + log(f_t_csi_2_1)
loglambda2 = M2_lambda %*% theta + log(f_t_csi_1_2)
logmu2 = M2_mu %*% theta + log(f_t_csi_2_2)
# Aparecem NAs quando t1 = t2 daí log(0) = -Inf
as.numeric(
(-1) *( - sum(lambda1) - sum(mu1) - sum(lambda2) - sum(mu2) +
sum(H1*loglambda1, na.rm = TRUE) + sum(A1*logmu1, na.rm = TRUE) + sum(H2*loglambda2, na.rm = TRUE) + sum(A2*logmu2, na.rm = TRUE) +
t(U1) %*% log(pi1) + t(U2) %*% log(pi2) - sum(pi1) - sum(pi2))
)
}
set.seed(1)
solution = solnp(pars = rep(1, 2*n+12), log_lik)
duration = Sys.time() - t0
mod_4_Rsolnp = list(alpha = c(0, solution$pars[1:(n-1)]),
beta = solution$pars[n:(2*n-1)],
gamma = solution$pars[2*n],
tau = solution$pars[2*n+1],
lambda_xy = solution$pars[c(2*n+2, 2*n+3)],
mu_xy = solution$pars[c(2*n+4, 2*n+5)],
eta = solution$pars[c(2*n+6, 2*n+7)],
phi = solution$pars[c(2*n+8, 2*n+9)],
kappa = solution$pars[2*n+10],
csi = solution$pars[c(2*n+11, 2*n+12)],
value = -solution$values[length(solution$values)],
duration = duration)
names(mod_4_Rsolnp$alpha) = times$Time
names(mod_4_Rsolnp$beta) = times$Time
names(mod_4_Rsolnp$lambda_xy) = c("10", "01")
names(mod_4_Rsolnp$mu_xy) = c("10", "01")
# save(mod_4_Rsolnp, file = "mod_4_Rsolnp.RData")
mod_4_Rsolnp
source('~/diss/code/mod_4_Rsolnp.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_4_Rsolnp.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/mod_4_Rsolnp.R', encoding = 'UTF-8', echo=TRUE)
mod_4_Rsolnp
source('~/diss/code/mod_4_Rsolnp.R', encoding = 'UTF-8', echo=TRUE)
source('~/diss/code/lixo/modelos série A 2019 v2/teste_mod_2.R', echo=TRUE)
source('~/diss/code/lixo/modelos série A 2019 v2/teste_mod_2.R', echo=TRUE)
dim(M1_lambda)
dim(theta)
names(M1_lambda)
colnames(M1_lambda)
source('~/diss/code/lixo/modelos série A 2019 v2/teste_mod_2.R', echo=TRUE)
source("pred_mod_0.R")
source("pred_mod_1.R")
source("pred_mod_2.R")
source("pred_mod_3.R")
pred_mod_0(home_team = "Flamengo", away_team = "Vasco da Gama")
pred_mod_1(home_team = "Flamengo", away_team = "Vasco da Gama")
pred_mod_2(home_team = "Flamengo", away_team = "Vasco da Gama")
pred_mod_3(home_team = "Flamengo", away_team = "Vasco da Gama")
source('~/diss/code/teste_mod_3.R', echo=TRUE)
mod_3
load("data/mod_3.RData")
load("mod_3.RData")
mod_3
source('~/diss/code/teste_mod_3.R', echo=TRUE)
mod_3
delta1
log(delta1)
min(delta1)
log(0)
log(delta1)
H1[674]
A1[674]
